## DHT (分布式 Hash table)

有很多种具体实现
Kad网络主要解决信息检索问题, 只要知道一个文件的key，就能够在整个
网络中查到具体存放的节点

##### 需要解决的问题
* 不需要服务器 通过 DHT
* 资源的存储／备份
  存储的数据叫做Value，每个值都有一个key, 每条记录由值和key组成，作为kad网络中的
    　　基本信息结构储存在本地机器中

* 加入网络
  当一个新节点首次试图加入Kad网络时，它必须做三件事，
    1. 不管通过何种途径，获知一个已经加入Kad网络的节点信息(我们可以称之为节点I)
       并将该节点加入自己的k-buckets；
          初始节点一般是写死的一些长时间在线节点

    2. 向该节点发起一次针对自己ID的节点查询请求，
       从而通过节点I获取一系列与自己距离邻近的其他节点的信息；
    3. 刷新所有的k-bucket，保证自己所获得的节点信息全部都是新鲜的
  

* 资源的查询
   所有资源根据自身value以及锁定了在网络中哪个节点来存储这些数据
   查找资源时，首先计算该数据所在的节点id, 让后在自己的路由表中查找
   离这个目标ｉｄ最近的已知节点，依次递归下去直到找到.不同节点之间的距离
   为节点id的异或值

   kad网络维护者两张DHT，一个叫做关键字表，一个叫做文件索引表
   1. 关键字表-作用
     主要根据查询的关键字，给出包含这些关键字的文件级相关信息
     其中key的值为所给关键字的SHA1,对应的value为一个列表,这个表中
     给出了所有文件名包含该关键字的文件信息。
     文件信息格式为３元祖 {文件名，文件大小，文件SHA1值}

  2. 文件索引表的作用
    通过给定的文件SHA1,查找到存储该文件的节点
    key:为文件的SHA1值，value为一个列表，包含当前用于给文件
    的节点信息. 格式为３元祖{IP, Port, 节点ID}
    

    注:这两个DHT表，是分布式的存放在网络的所有节点中，并不是集中的

* 节点查询,路由
   查询与给定节点最近的K个节点
   类似与DNS迭代查询
   1.首先在自己的路由表中筛选出几个与目标节点最近的节点
   2. 分别想这些节点发送查询请求
   3. 别查询节点收到请求后，在自己的路由表中查询，返回自己知道的离该节点最近的N个节点
   4. 查询节点收到返回信息后, 在找出离指定节点最近的N个节点，还没有请求过的节点
   　　发送请求
   5. 一直持续该过程，直到无法获得比当前所知节点更近的节点为止
   说明: 在查询中，没有及时相应的节点将会被排除

   
由于每个 K 桶覆盖距离的范围呈指数关系增长，这就形成了离自己近的节点的信息多，离自己远的节点的信息少，从而可以保证路由查询过程是收敛
 Kad网络并不支持模糊搜索或部分搜索
 保存关键字表
 把对应的Key存放到和该key距离最近的K个节点

* 资源的下载


* 资源的上传
  1. 计算上传资源的key
  2. 根据该文件的SHA1(key)值存放在和给文件SHA1最近的N个节点上
  冗余性. N的取指是保证当前网络同一时刻这些节点不在线的概率几乎为０
  N的典型取指为20

    

* 离开网络


#### Kademlia(Kad)
电驴使用的和磁力线使用的都是基于kad的技术，但是具体
　对key,value, nodeID的计算方法不同
* 使用UDP


* 节点
  Id
  每个节点都有一个网络唯一的nodeId 160bit.这个ID根据一些硬件指标计算
  (比如网卡Mac地址)
  kad把每个节点看做一颗大的二叉树的中个一个叶子
    可以把一段0101010111 看做成为一颗二叉树中的一个节点
    ０为左分支，１为右分支
      e.g. 0101
        /\
       0  1
       \
        1
       /
       0
       \
       1

  * 每个节点根据自己的Id,决定哪些文件存放在自己节点

* 所有的key和nodeId 都是160bit
   数据存放在和该数据key最"近"的节点上

* 节点间距离: kad网络使用的距离并不是物理距离或者是路由距离。
　　　　　　而是异或运算, 把NodeId ox key 得到的数值就是距离值
  XOR
 为什么要使用异或计算?
 1. 对称性
     A xor B == B xor X
 2. 复合三角不等式
 　　　A　xor C < A xor B + B xor C
 3.单向性
   距离>=0
    单向性也确保了对于同一个 key 值的所有查询都会逐步收敛到同一个路径上，而不管查询的起始节点位置如何。这样，只要沿着查询路径上的节点都缓存这个 <key,value> 对，就可以减轻存放热门 key 值节点的压力，同时也能够加快查询响应速度。

 使用异或将大大降低节点距离的计算量，
 在Kad中查询，每一次至少获得据目标更近１bit的节点, 一个2^160的网络，最后情况下
 只需要160次查询，就可以找到被搜索的节点

* 路由表
   每个节点都有一张路由表，这个表由N个key桶组成
   N整个DHT网络的方. 第i个桶中存放，距离当前节点为2^i ~2^(i+1)-1
   最近的的节点信息
   注: 这样的好处是，每个节点都存放离自己最近的节点更多,离自己远的节点会越来越少

* Key 桶
    每个k桶存放的数据不超过k条。最新的数据在最上面



#####协议
* 共有四种消息
* ping 用来测试节点是否存活
* findNode 向一个node发出查找指定node的请求
* findValue像一个节点发出资源请求
* Store 在某节点中存储一个建值对

### 编码
 bencode
一种用在bt上的编码格式，可读机器体系无关，可存储复杂类型
BT 种子和测力连接都是由bencode编码的文件


### DHT 爬虫
要实现DHT协议的网络爬虫，主要分3步，
1. 得到资源信息(infohash，160bit，20字节，可以编码为40字节的十六进制字符串)，
2. 确认这些infohash是有效的
3. 第三步是通过有效的infohash下载到BT的种子文件，从而得到对这个资源的完整描述


