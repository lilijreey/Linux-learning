## 垃圾回收
GC 属于内存管理的一部分,是自动化的堆内存管理技术。


### GC 能够实现的必要条件
??

GC 需要做两件事
1. 找到垃圾内存（已不在使用的内存)
2. 回收。


### GC单位
* 对象gc回收的基本单位，对象由head,和field组成
* head 
  保存对象的元信息
   * 对象大小
   * 对象类型
   * 其他管理信息
* field
  分为指针数据和非指针数据
  作为算法实现原因，规定指针只能执行对象的首地址
  

### 算法分类
* 引用计数方式和追踪方式
* 保守方式和精确方式
* 迁移方式和非迁移方式（对象是否会移动)
* 实时和非实时(是否需要停止程序执行)


### 标记-清扫
第一个GC算法在Lisp中被实现
* 活动对象
  可以通过根指针找到的对象
* 非活动对象
  不发通过根指针找到的对象(可以被回收的对象)

* gc 流程
  1. 初始化堆
  2. 分配
  3. 当内存不足时出发GC

* root 根
  * GC通过树型结构管理对象 通过根节点可以访问到所有活着的对象
  * 根节点不止一个，全局对象，调用栈,寄存器中的对象也都是根对象(森林)

* 标记(mark)
  从root递归的标记每个对象
  遍历时通常使用深度优先遍历，因为使用的内存更少

* 清扫
  * 回收是把空闲对象放到一个空闲链表中
  遍历整个堆，回收没有被标记的对象.
  也可以使用链表存放所有对象。这里遍历链表即可
  如果是堆，由于每个对象都有obj.size所以可以找到下一个对象
  下一个对象有可能是死的，没关系

* 分配
  在空闲列表中寻找大小合适的对象
  1. 遍历数组找到一个大于等于要求size的对象
  2. 如果有空余空间，则把当前对象分割成两个对象
  * 选择那个对象返回有三种主要的策略
    1. First-fit 第一个>= size的对象
    2. Best-fit 返回> size的最小对象
    3. Worst-fit 返回> size的最大对象

* 合并
  把连续的空闲对象合并成一个对象，减少内存碎片
  合并是在清扫阶段进行的
  1. 遍历堆把所有标记的对象，设置成未标记（未下次mark做准备)
  2. 对所有未标记对象检查是否可以合并


* 特性
  * 实现简单
  * 不会移动对象,兼容保守GC算法
  * 容易产生大量碎片,利用率不高
  * 分配速度O(n)

* 改进
  1. 使用多个空闲列表，根据对象的大小来管理(可以演变到伙伴系统)
     增加内存利用率，减少内存碎片
  2. 以固定大小分配对象
  3. 把元数据和对象数据分开存储, 写时复制友好
     由于元信息和数据信息在一起，导致fork后，对元信息的改变会导致对对象进行
     内存分配。 通过使用位图标记(bitmap)
     堆中的一个字节用一个bit来标示
  4. 延迟清除 减少清除时间
     分配的时候在已经死亡的对象中进行分配


### 标记-紧缩
### 标记-复制

## 引用计数
* Strity 引用
* 1位引用


### 分代GC 

一个c/C++的GC库 hboehm 


## 保守垃圾回收 (conservative GC)
可能漏掉一些垃圾, 不能识别指针和非指针的GC算法
* 对于c/c++的GC来说，很多值有可能是指针，但也可能不是,无法正确的识别指针
* 指针的识别
   保守式GC会先在root对象中识别指针
   识别方法:
     1. 存的值是否是对齐的
     2. 值是否在堆范围中
     3. 其他检查
* 保守式GC有可能会把非指针值识别成指针,但是不会造成错误。
   因为会保留对象


## 准确是GC
需要语言支持。
1.区分指针和非指针值 
  * 打标签: 由于指针的0bit一定是0，所以可以讲非指针值左移一位，0bit设为1.
    这样就可以准确区分指针和非指针值。处理非指针值时需要先还原

  * 不把栈寄存器作为根,使用统一的根来管理


* 写屏蔽技术
Qus. 如果实现??


## 增量垃圾回收
主要用在实时性高的程序中
每次只执行一部分GC工作
Lua/Io使用的就是


### GC 算法评价标准
* 吞吐量
   单位事件的GC回收数量
* 最大暂停时间
* 堆使用率
* 访问局部性
* 是否可以并行
* 对线程友好

## 有关垃圾回收资料
* 松本行宫的程序世界


## C/C++ GC库
* Doehm-Demers-Weiser GC
   bdwgc

